-- Feel free to modify this file to match your development goal.
-- Here we only create 3 tables for demo purpose.

-- CREATE TABLE Users (
--     id INT NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
--     email VARCHAR UNIQUE NOT NULL,
--     password VARCHAR(255) NOT NULL,
--     firstname VARCHAR(255) NOT NULL,
--     lastname VARCHAR(255) NOT NULL
-- );

-- CREATE TABLE Products (
--     id INT NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
--     name VARCHAR(255) UNIQUE NOT NULL,
--     price DECIMAL(12,2) NOT NULL,
--     available BOOLEAN DEFAULT TRUE
-- );

-- CREATE TABLE Purchases (
--     id INT NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
--     uid INT NOT NULL REFERENCES Users(id),
--     pid INT NOT NULL REFERENCES Products(id),
--     time_purchased timestamp without time zone NOT NULL DEFAULT (current_timestamp AT TIME ZONE 'UTC')
-- );

CREATE TABLE Users(
	uid INTEGER PRIMARY KEY NOT NULL, 
	email VARCHAR(100) UNIQUE NOT NULL, 
	full_name VARCHAR(150) NOT NULL,
	address TEXT NOT NULL,
	password VARCHAR(256) NOT NULL,
  phone_number VARCHAR(10) NOT NULL, 
	balance DECIMAL(10, 2) DEFAULT 0 
);

CREATE TABLE Seller (
	sid INTEGER PRIMARY KEY NOT NULL REFERENCES Users(uid)
);

CREATE TABLE Product (
  pid INTEGER PRIMARY KEY NOT NULL,
	name VARCHAR(400)NOT NULL,
  description VARCHAR(4096) NOT NULL,
  image VARCHAR(400) NOT NULL,
  altTxt VARCHAR(4096) NOT NULL,
  CreatedAt DATETIME,
  UpdatedAt DATETIME

);

CREATE TABLE Category (
pid INTEGER PRIMARY KEY NOT NULL REFERENCES Product(pid), 
	name VARCHAR(400)NOT NULL
);

CREATE TABLE Tag (
pid INTEGER PRIMARY KEY NOT NULL REFERENCES Product(pid),
name VARCHAR(400)NOT NULL
);

CREATE TABLE Purchases(
  uid INTEGER NOT NULL REFERENCES Users(uid),
	sid INTEGER NOT NULL REFERENCES Seller(sid),
  pid INTEGER NOT NULL REFERENCES Product(pid), 
	order_id INTEGER NOT NULL,
  date_purchased TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	quantity INTEGER NOT NULL,
	date_fulfilled TIMESTAMP,
	PRIMARY KEY (sid, pid, uid, order_id)
);

CREATE TABLE Inventory (
	sid INTEGER NOT NULL REFERENCES Seller(sid),
	pid INTEGER NOT NULL REFERENCES Product(pid),
	quantity INTEGER NOT NULL,	
	num_for_sale INTEGER NOT NULL,
	price INTEGER NOT NULL
	PRIMARY KEY (sid, pid)
);

CREATE TABLE SellerFeedback(
	uid INTEGER NOT NULL REFERENCES Users(uid), 
	sid INTEGER NOT NULL REFERENCES Seller(sid),
	rating INTEGER NOT NULL CHECK(rating BETWEEN 1 and 5), -- should a user leave any feedback, they must leave a rating 
  review VARCHAR(4096), -- can be null because leaving a review is optional 
  date_time TIMESTAMP NOT NULL, -- YYYY-MM-DD hh:mm:ss
  PRIMARY KEY (uid, sid)  
);

CREATE TABLE ProductFeedback(
	uid INTEGER NOT NULL REFERENCES Users(uid), 
	pid INTEGER NOT NULL REFERENCES Product(pid),
	rating INTEGER NOT NULL CHECK(rating BETWEEN 1 and 5), -- should a user leave any feedback, they must leave a rating 
	review VARCHAR(4096), -- can be null because leaving a review is optional 
  date_time TIMESTAMP NOT NULL, -- YYYY-MM-DD hh:mm:ss
  PRIMARY KEY (uid, pid) 	
);

CREATE TABLE Message(
	sender_id INTEGER NOT NULL REFERENCES Users(uid),
	receiver_id INTEGER NOT NULL REFERENCES Users(uid),
  date_time TIMESTAMP NOT NULL, -- YYYY-MM-DD hh:mm:ss
	msg VARCHAR(4096) NOT NULL, -- cannot be null because a message must occur in order for it be recorded in this table  
  PRIMARY KEY (sender_id, receiver_id, date_time) 
);

CREATE TABLE Cart(
	uid INTEGER NOT NULL REFERENCES User(uid), 
	sid INTEGER NOT NULL REFERENCES Seller(sid),
  pid INTEGER NOT NULL REFERENCES Product(pid),
  quantity INTEGER NOT NULL,
  unit_price INTEGER NOT NULL REFERENCES UserPrice(unit_price),
  total_price INTEGER NOT NULL,
  saved_for_later BIT DEFAULT 0;
  PRIMARY KEY (uid, sid, pid) 
  -- total price is quantity x price of item
  -- saved for later vs in cart (default)
  -- one line is identified by user, seller, and product which is for one quantity of item in that userâ€™s cart
);


----------------------------------------------------------------------
-- feedback constraints

CREATE FUNCTION FeedbackConstraints() RETURNS TRIGGER AS $$
BEGIN

  IF TG_TABLE_NAME = 'sellerfeedback' THEN 
    IF NEW.sid NOT IN (SELECT p.sid FROM Purchases as p where p.uid = NEW.uid) THEN 
    -- constraint that no user can leave any feedback for a seller they have not ordered from 
      RAISE EXCEPTION 'A user cannot leave any feedback for a seller they have not purchased from.';
    END IF; 
    -- the prior constraint applies to both insert and update statements
    -- the next constraint applies only to insertions 
    IF TG_OP = 'INSERT' THEN
        IF NEW.sid IN (SELECT f.sid from SellerFeedback as f where f.uid = NEW.uid) THEN
        -- constraint that each user can submit only one rating/review for a seller 
          RAISE EXCEPTION 'A user can leave at most one rating and review for each seller they have purchased from.'; 
        END IF; 
    END IF; 
  END IF;

  IF TG_TABLE_NAME = 'productfeedback' THEN 
    IF NEW.pid NOT IN (SELECT p.pid from Purchases as p where p.pid = NEW.pid) THEN 
    -- constraint that no user can leave any feedback for a product they have never purchased  
      RAISE EXCEPTION 'A user cannot leave any feedback for a product they have never purchased.';
    END IF;     
    -- the prior constraint applies to both insert and update statements
    -- the next constraint applies only to insertions 
    IF TG_OP = 'INSERT' THEN
        IF NEW.pid IN (SELECT f.pid from ProductFeedback as f where f.uid = NEW.uid) THEN
        -- constraint that each user can submit only one rating/review for a product 
            RAISE EXCEPTION 'A user can leave at most one rating and review for each product purchased.'; 
        END IF; 
    END IF; 
  END IF;
  RETURN NEW;

END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER SellerFeedbackConstraints
  BEFORE INSERT OR UPDATE ON SellerFeedback -- deletions are ok 
  FOR EACH ROW
  EXECUTE PROCEDURE FeedbackConstraints();

CREATE TRIGGER ProductFeedbackConstraints
  BEFORE INSERT OR UPDATE ON ProductFeedback -- deletions are ok 
  FOR EACH ROW
  EXECUTE PROCEDURE FeedbackConstraints();

----------------------------------------------------------------------
-- inventory constraints

CREATE FUNCTION InventoryConstraints() RETURNS TRIGGER AS $$
BEGIN
  -- constraints the numeric values in quantity, price, and num_for_sale
  IF NEW.quantity < 0 THEN
    RAISE EXCEPTION 'Quantity of an product cannot be less than 0.';
  IF NEW.price < 0 THEN
    RAISE EXCEPTION 'Price of a product cannot be less than 0.';
  IF NEW.num_for_sale < 0 OR NEW.num_for_scale > NEW.quanity THEN
    RAISE EXCEPTION 'Number of product for sale cannot be less than 0 or exceed the quantity of the product.';

END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER InventoryConstraints
  BEFORE INSERT OR UPDATE ON Inventory
  FOR EACH ROW
  EXECUTE PROCEDURE InventoryConstraints();

----------------------------------------------------------------------
-- purchases constraints

CREATE FUNCTION PurchaseConstraints() RETURNS TRIGGER AS $$
BEGIN
  
  IF NEW.price < 0 THEN
  RAISE EXCEPTION 'Price of a product cannot be less than 0.';

END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER PurchaseConstraints
  BEFORE INSERT OR UPDATE ON Purchases
  FOR EACH ROW
  EXECUTE PROCEDURE PurchaseConstraints();